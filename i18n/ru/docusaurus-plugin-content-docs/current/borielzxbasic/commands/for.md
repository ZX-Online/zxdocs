# FOR ... NEXT

## Синтаксис

```
 FOR <итератор> = <начальное_значение> TO <конечное_значение> [ STEP <шаг> ]
   [ <какой-то код> ]
 NEXT [ <итератор> ]
```
## Параметры

* _итератор_: идентификатор переменной, который используется для передачи значения в каждом цикле; её значение меняется от начального значения до конечного значения.
* _тип данных_: Если задан, то итератор будет автоматически создан со значением указанного типа.
* _начальное значение_: выражение, которое задаёт начальное значение итератора.
* _конечное значение_: выражение, которое используется для сравнения со значением итератора.
* _шаг_: выражение, которое добавляется к итератору после каждого прохода по циклу.

## Описание

Цикл **For...Next** записывает _начальное значение_ в _итератор_, после чего выполняет код внутри цикла _какой-то код_, увеличивает _итератор_ на величину _шаг_, пока он не достигнет или не превысит значения _конечное значение_. Если _шаг_ не задан явно, то он будет по умолчанию равен 1.

## Примеры

```
REM Посчитаем от 1 до 10
FOR i = 1 TO 10: PRINT i: NEXT
```

### Считаем в обратную сторону
```
FOR i = 10 TO 1 STEP -1: PRINT i: NEXT
```

### Используем нечётные числа в цикле
```
FOR i = 1 TO 10 STEP 2: PRINT i: NEXT
```

## Отличия от Sinclair Basic

* Переменная после `NEXT` не обязательна.
* Помните, что типы переменных могут вызывать различные проблемы с циклами `For...Next` в Boriel ZX Basic. Если верхний предел итератора превышает верхний предел типа использованного для итератора, то цикл может не завершиться.

Вот пример:
```
DIM i as UByte

FOR i = 1 to 300
    PRINT i
NEXT i
```

Очевидно, что поскольку наибольшее значение, которое может хранить байт, равно 255, то невозможно, чтобы `i` в приведенном выше примере было равно или превышало 300.

Переменная после 255 сбросится в 0, и в результате цикл не завершится.

При использовании `STEP` это может произойти гораздо более тонким образом. В типе переменной должно быть "место" для того, чтобы итератор мог выйти за пределы максимального значения, когда он увеличивается на `шаг`.

Например, рассмотрим такой пример:

```
DIM i as UInteger

FOR i = 65000 TO 65500 STEP 100
 ...
NEXT i
```

Этот цикл никогда не закончится. Тип `UInteger` допускает значения в диапазоне `[0..65535]`, так что, очевидно, это нормально, потому что 65500 находится внутри него. Однако `STEP` равен 100, поэтому 65500 + 100 = 65600, что выпадает из этого диапазона. Произойдет _переполнение_ и переменная `i` примет значение 64 и цикл продолжится почти сначала.

## Также смотрите

* [WHILE ... END WHILE](while)
* [DO ... LOOP](do)
* [IF ... END IF](if)
* [EXIT](exit)
* [CONTINUE](continue)
* [Руководство Sinclair Basic](http://www.worldofspectrum.org/ZXBasicManual/zxmanchap4.html)

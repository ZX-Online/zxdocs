---
sidebar_position: 2
title: От Sinclair ZX Basic к Boriel ZX Basic
---

> Это перевод [оригинальной статьи "De Sinclair ZX Basic a Boriel ZX Basic"](https://specnext.dev/es/2022/07/30/de-sinclair-zx-basic-a-boriel-zx-basic/) с испанского языка.

В этой статье мы объясним ряд концепций Boriel ZX Basic, ориентированных на программистов, которые пришли из классического Sinclair ZX Basic, и которые хотят начать программировать на Boriel ZX Basic. И хотя концепты полезны для классического ZX Spectrum, мы больше сосредоточимся на ZX Spectrum Next.

Невозможно обобщить или объяснить все в простой статье, и это не тот путь, который можно пройти за 2 минуты, поэтому в этом тексте мы объясним общие концепции, не вдаваясь в излишние подробности или продвинутые вопросы.

Чтобы выполнить шаги, описанные в этой статье, лучше всего иметь готовую среду программирования NextBuild, о которой мы рассказывали в статье "Подготовка среды для программирования для Next с помощью Boriel ZX Basic и NextBuild".

Для тестирования примеров мы создадим папку "Test" внутри "C:\ZXNext\NextBuildv7\Sources". После создания этой папки мы можем создать, например, файл "Test1.bas" и запустить в нем тесты.

## Но что дает мне Boriel ZX Basic?

Это первый вопрос, который обычно задают себе программисты, услышав о Boriel ZX Basic (далее Boriel). И ответ не прост, не потому что сложно объяснить, что он дает, а потому что это длинный ответ:

1. **Он компилирует код**: Boriel - это компилятор, что означает, что Boriel "преобразует" наш BASIC-код в машинный код. В отличие от него Sinclair ZX BASIC является интерпретируемым языком, что означает, что каждый раз, когда команда должна быть выполнена, ПЗУ должно прочитать, декодировать и выполнить ее. В отличие от этого, скомпилированный код выполняется намного быстрее.
1. **Оптимизирует код**: после компиляции Boriel может оптимизировать наш код, чтобы он стал еще быстрее и занимал меньше памяти. Например, большинство математических операций выполняются быстрее, CIRCLE работает быстрее, PRINT летает, и так далее, и так далее. Другим важным аспектом является то, что код, который никогда не выполняется, исключается, что уменьшает объем используемой памяти.
1. **Включает в себя усовершенствования языка**: Boriel добавляет возможности современных языков, таких как C или Visual Basic, и даже позволяет использовать ассемблер и обеспечивает простое взаимодействие между ним и Boriel, например, облегчая доступ к переменным BASIC из ассемблера.
1. **Позволяет структурировать код**: Структурирование кода делает код более удобным для чтения, и в то же время его легче повторно использовать в других проектах.
1. **Уменьшает порог входа для ассемблера**: Многие из нас, или, по крайней мере, я, сталкивались с барьером скорости. Игры на BASIC были медленными, а ассемблер - очень сложным. Boriel позволяет нам постепенно и очень естественно интегрировать ассемблер в наши программы.
1. **Поддержка**: Telegram-канал "Boriel ZX Basic" или форум Boriel очень активны, и создатель компилятора "Boriel", Boriel, довольно часто зависает на этих каналах.

## Различия между Sinclair ZX Basic и Boriel ZX Basic

Boriel на 95% совместим с Sinclair ZX Basic. В следующем списке мы можем увидеть основные различия:

### Номера строк

В Boriel они необязательны, т.е. вам не нужно ставить номера строк, что является одной проблемой, поскольку вам не нужно беспокоиться о нумерации или ограничении в 9999 строк.

```basic
10 BORDER 0: PAPER 0: INK 6: CLS
20 FOR N=0 TO 20
30 PRINT N
40 NEXT N
```

Это записывается как:

```basic
BORDER 0: PAPER 0: INK 6: CLS
FOR N=0 TO 20
     PRINT N
NEXT N
```

Обратите внимание, что мы отделяем PRINT символом табуляции перед ним, что облегчает чтение кода.

### Метки

Именно этот механизм в Boriel позволяет нам устранить номера строк. Вместо "GO TO 1000" или "GO SUB 1000" можно использовать "GO TO MyLabel" или "GO SUB MyLabel", а вместо строки 1000 поставить "MyLabel:".

```basic
10 LET A=0
20 LET A=A+1
30 PRINT AT 0,0;A
40 IF A<100 THEN GOTO 20
50 PRINT "END"
```

Это можно записать так:

```basic
LET A=0
Loop:
	LET A=A+1
	PRINT AT 0,0;A
	IF A<100 THEN GOTO Loop
PRINT "END"
```

### Вычисляемые переходы

Boriel не разрешает переходы типа `GO TO 1000+variable` или `GO TO variable`. В этом случае необходимо немного изменить концепцию или использовать таблицы переходов с командой `ON GOTO` или `ON GOSUB`, например: `ON variable GOTO 1000,1100,1200` перейдет на строку 1000, если переменная равна 0, на 1100, если она равна 1, на 1200, если она равна 2, и не перейдет, если она имеет любое другое значение.

```basic
10 GOTO 1000+(variable*100)
```

Это придётся записать так:

```basic
ON variable GOTO 1000,1100,1200
```

### Основание массива

Хотя параметр `-sinclair` в Boriel изменяет это поведение, по умолчанию индексы массивов `DIM a(100)` в Boriel начинаются с 0, а в Sinclair ZX Basic - с 1. Это означает, что этот `DIM a(100)` в Boriel будет иметь 101 элемент (от 0 до 100), а в Sinclair ZX Basic - только 100 (от 1 до 100).

Старт с 0 также применяется к оператору "TO" в строковых операциях:

```basic
LET A$="12345"
PRINT A$(1 TO 4)
```

На Sinclair ZX Basic он выведет "1234", а на Boriel - "2345".

Это поведение можно изменить с помощью параметров "-sinclair", "-array-base" и "-string-base", но самым обычным является привычка использовать 0 в качестве базового элемента.

### Строковые переменные без $

Использование $ для ссылки на текстовую переменную больше не обязательно, т.е. мы можем использовать `a="Hello"` вместо `a$="Hello"`.

Это также означает, что A является той же переменной, что и A$.

### Команды по умолчанию

Если не указано иное, не все команды Sinclair ZX Basic доступны, если мы не используем модификатор "-sinclair", хотя это не проблема, далеко не проблема, как мы увидим позже. Некоторые из этих команд - INPUT, ATTR и SCREEN$.

## Усовершенствования Boriel ZX Basic

Boriel улучшает Sinclair ZX BASIC, расширяя и делая его более гибким, позволяя нам использовать современные методы, которые до сих пор были доступны только в других языках, таких как C.

### Новые типы переменных

Переменные в Sinclair ZX Basic могут быть только двух типов - числовые или текстовые.

Числовые переменные всегда имеют тип FLOAT и всегда занимают 5 байт. Все математические операции, независимо от того, насколько они просты, проходят через калькулятор с плавающей запятой, что сильно замедляет выполнение.

Boriel включает в себя 6 типов переменных для целых чисел, два типа для чисел с десятичными дробями и один для текстовых строк. Если вы не укажете тип переменной, Boriel попытается присвоить наиболее подходящую, но это немного опасно, поэтому рекомендуется всегда определять тип переменной.

В следующей таблице представлены типы числовых переменных:

| Тип | Размер (байт) | Диапазон | Описание |
|-----|---------------|----------|----------|
| Byte | 1 | -128..127 | Знаковое 8-битное целое число
| UByte | 1 | 0..255 | Беззнаковое 8-битное целое число
| Integer | 2 | -32768..32767 | Знаковое 16-битное число
| UInteger | 2 | 0..65535 | Беззнаковое 16-битное число
| Long | 4 | -2147483648..+2147483647 | Знаковое 32-битное число
| ULong | 4 | 0..4294967295 | Беззнаковое 32-битное число

Что касается десятичных дробей, то у нас есть следующие типы:

| Тип | Размер (байт) | Диапазон | Описание |
|-----|---------------|----------|----------|
| Fixed | 4 | -32767.9999847..32767.9999847 | 16 бит для целочисленной части и 16 бит для десятичной части
| Float | 5 | Теряет точность при работе с большим количеством десятичных дробей или с очень большими числами | Этот тип используется в Sinclair ZX Basic. 8 бит для экспоненты и 24 бита для мантиссы (данных).

Текстовые строки не имеют заданного размера и занимают 2 байта плюс содержимое текста. Эти дополнительные два байта содержат фактический размер текста. Текстовые переменные определяются с помощью ключа `string`.

Boriel позволяет нам определить тип переменных, которые мы хотим использовать, что позволяет нам ускорить операции, выполняемые с этой переменной. Мы можем определить переменные следующим образом:

```basic
DIM numberSmall AS BYTE
DIM numberSmallNoSign AS UBYTE
DIM numberInteger1, numberInteger2 AS UINTEGER
DIM str AS STRING
DIM arrayInteger(100) AS UINTEGER
DIM arrayBidimensional(10,5) AS UBYTE
```

Следует отметить, что значение, указываемое при объявлении массива, указывает на количество элементов +1, так как индексы начинаются с 0. Короче говоря, 100 определяет, что он имеет 101 элемент, от 0 до 100.

Рекомендуется использовать наименьший возможный тип переменной, но будьте осторожны, чтобы не превысить максимальное и минимальное значения.

### Подпрограммы

В Sinclair ZX Basic подпрограммы вызываются командой `GOSUB line`, а возврат из них осуществляется командой `RETURN`:

```basic
10 LET Y=10
20 LET X=5
30 LET A$="HELLO"
30 GOSUB 1000
...
1000 PRINT AT Y,X;A$
1010 RETURN
```

Подпрограммы имеют ряд недостатков, например, пример выводит текст, содержащийся в A$ в строке Y и столбце X, но у нас нет ссылки на необходимые переменные.

В Boriel мы можем реализовать это следующим образом:

```basic
Print(10,5, "Hello")
...
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	PRINT AT Y,X;TEXT
END SUB
```

Как видно из примера на Boriel, переменные, требуемые подпрограммой, легко понять. Кстати, эти переменные называются "параметрами", то есть они являются параметрами подпрограммы.

В некотором смысле, `SUB` позволяют нам создавать свои собственные команды.

Давайте рассмотрим некоторые варианты:

```basic
DIM Row, Column AS UBYTE
Row=10
Column=5
Print(Row,Column, "Hello")
...
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	PRINT AT Y,X;TEXT
END SUB
```

Здесь мы видим, что в качестве параметров можно использовать переменные.

Теперь давайте улучшим процедуру печати:

```basic
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	DIM N, COLOR AS UBYTE
    COLOR=0
	PRINT AT Y,X;"";
	FOR N=0 TO LEN(TEXT)-1
		PRINT INK COLOR;TEXT(N);
		COLOR=COLOR+1
	NEXT N
END SUB
```

В этом примере мы улучшили подпрограмму Print, которая теперь печатает текст в цветах, но самое интересное, что мы определили две переменные ("N" и "COLOR"). Эти переменные "живут" только внутри SUB, то есть, когда мы вызываем подпрограмму, создаются две новые переменные, а когда мы выходим из подпрограммы, они будут уничтожены.

Результатом является то, что мы можем иметь переменную с тем же именем вне SUB, например:

```basic
DIM N AS UBYTE
FOR N=0 TO 10
	Print(N,0, "HELLO "+STR(N))
NEXT N
...
SUB Print(Y AS UBYTE, X AS UBYTE, TEXT AS STRING)
	DIM N, COLOR AS UBYTE
	COLOR=0
	PRINT AT Y,X;"";
	FOR N=0 TO LEN(TEXT)-1
    	PRINT INK COLOR;TEXT(N);
        COLOR=COLOR+1
	NEXT N
END SUB
```

Этот пример печатает текст "HELLO 0", "HELLO 1", "HELLO 2", вплоть до "HELLO 10", в разных строках. Но самое любопытное, что у нас есть первый цикл, который использует переменную "N" (которая является глобальной переменной), и другая переменная с тем же именем "N" внутри SUB (которая называется локальной переменной), но они разные и их значения не смешиваются.

### Функции

FUNCTION - это подпрограмма (SUB), которая возвращает значение.

Рассмотрим пример:

```basic
PRINT Sum(10,3)
...
FUNCTION Sum(A AS INTEGER, B AS INTEGER) AS INTEGER
	DIM R AS INTEGER
	R=A+B
	RETURN R
END FUNCTION
```

В этом примере мы определяем функцию `Sum`, которая складывает два значения типа INTEGER и возвращает результат в виде INTEGER. Очевидно, что его можно и нужно упростить с помощью простого `RETURN A+B`, но таким образом мы видим, что тут "локальные" переменные тоже могут быть использованы.

### Интеграция с ассемблером

Хотя это продвинутая функция, мы объясним простым способом, как добавить несколько ассемблерных строк в наш код. Давайте рассмотрим пример из NextLib:

```basic
function GetReg(byval nextRegister as ubyte) as ubyte
asm
	push bc
	ld bc,$243B                                        ; Выбор регистра
	out(c),a
	ld bc,$253B                                        ; Доступ к данным регистра
	in a,(c)
	pop bc
end asm
end function
```

В этом примере реализована команда `GetReg`, которая считывает значение регистра Next (NextReg). Видно, что внутри функции ассемблерный код включен между строками, обозначенными "ASM" и "END ASM".

В этом случае параметр `nextRegister` помещается в регистр A процессора, и значение, возвращаемое функцией, также является тем, которое хранится в регистре A.

Код на ассемблере делает OUT на порту `$243B`, а затем делает IN на порту `$253B`. В результате значение регистра NextReg, на которое указывает параметр `nextRegister`, будет значением регистра NextReg.

Это также позволяет нам добавлять данные в наш код, например, определения шрифта или некоторых спрайтов, как вы можете видеть в этом примере:

```basic
Label:
ASM
db $E3, $E3, $E3, $E3, $E3, $F5, $F5, $F4, $F4, $F5, $F5, $E3, $E3, $E3, $E3, $E3;
db $E3, $E3, $E3, $FA, $F4, $F4, $F4, $F4, $F4, $F4, $F0, $ED, $F6, $E3, $E3, $E3;
db $E3, $E3, $F9, $F8, $F4, $F4, $F4, $F4, $F4, $F4, $F4, $ED, $E9, $F2, $E3, $E3;
db $E3, $FA, $F8, $F8, $F8, $F8, $F4, $F4, $F4, $F4, $F4, $EC, $E9, $E9, $F6, $E3;
db $E3, $F8, $F8, $F8, $F8, $F8, $F8, $F4, $F4, $F4, $F4, $ED, $E9, $E9, $ED, $E3;
db $F9, $F8, $F8, $F8, $F8, $F8, $F8, $F8, $F4, $F4, $F0, $ED, $E9, $E9, $E9, $F2;
db $F9, $F8, $F8, $D8, $B8, $B8, $D8, $F8, $F4, $F0, $ED, $E9, $E9, $E9, $E9, $ED;
db $F8, $D8, $98, $78, $58, $78, $78, $B4, $F0, $ED, $E9, $E9, $E9, $E9, $E9, $CE;
db $D8, $98, $58, $58, $59, $58, $55, $52, $CE, $E9, $E9, $E9, $E9, $E9, $CE, $AE;
db $B9, $58, $59, $58, $58, $55, $37, $53, $AF, $CE, $CE, $CE, $CE, $AE, $AE, $AF;
db $99, $58, $58, $58, $59, $36, $33, $33, $AF, $AE, $AE, $AE, $AE, $AE, $AE, $D3;
db $E3, $79, $58, $58, $55, $37, $33, $37, $6F, $AE, $AE, $AE, $AE, $AE, $AE, $E3;
db $E3, $9A, $58, $58, $55, $37, $33, $33, $33, $8F, $AF, $AE, $AE, $AE, $D7, $E3;
db $E3, $E3, $99, $58, $55, $37, $33, $33, $33, $37, $53, $8F, $8F, $B3, $E3, $E3;
db $E3, $E3, $E3, $99, $79, $36, $33, $33, $33, $33, $33, $37, $77, $E3, $E3, $E3;
db $E3, $E3, $E3, $E3, $E3, $7A, $37, $33, $33, $37, $77, $E3, $E3, $E3, $E3, $E3;
end asm
```

Разница между использованием этой системы и использованием DATA заключается в том, что в DB данные сразу помещаются в память. Вам не нужно читать его с помощью READ и выполнять POKE. Мы увидим это позже, но это большое преимущество.

Еще одна очень важная деталь - вам не нужно писать ORG на ассемблере. Бориэль размещает код в памяти, занимая свободные промежутки и перемещая код по мере программирования. Это позволяет нам немного забыть о карте памяти, хотя и не полностью, если мы, например, хотим поиграть с картой памяти.

### Использование библиотек

Библиотека - это файл кода, который содержит ряд подпрограмм и ФУНКЦИЙ, расширяющих доступные команды.

Boriel включает в себя довольно богатый пакет библиотек, в который входят, среди многих других, функции для чтения одновременно нажатых клавиш, функции для работы со строками, спрайтами, доступа к дискам и SD-картам, скроллинга и т.д..

Для использования встроенной библиотеки мы используем директиву `#include`, указывая имя библиотеки между большим и меньшим знаками (&lt;&gt;).

```basic
#include <Keys.bas>
…
IF MultiKeys(KEYSYMBOL)<>0 THEN PRINT "Symbol Shift pressed"
```

В этот пример включена библиотека "Keys.bas", которая реализует методы `GetKey`, `MultiKeys` и `GetKeyScanCode`, а также определяет ряд констант, позволяющих нам прочитать каждую из кнопок нашего любимого Spectrum.

Другой пример:

```basic
#include <Scroll.bas>
DIM Y, X, N AS UBYTE
FOR Y=0 TO 23
     FOR X=0 TO 31
          PRINT AT Y,X;"#";
     NEXT X
NEXT Y
WHILE INKEY$=""
    PRINT AT 10,11;N;
    N=N+1
    ScrollRight(80,40,200,120)
WEND
```

В этом примере экран заполняется символом "#", а затем прокручивается пиксель за пикселем в окне до тех пор, пока не будет нажата клавиша.

Цикл, образованный WHILE .. WEND заставляет все, что находится внутри, повторяться до тех пор, пока выполняется условие. В этом случае он будет прокручиваться до тех пор, пока не будет нажата клавиша, то есть когда INKEY$ не будет равен пустой строке.

Если мы хотим использовать библиотеку, которая не встроена в Boriel, мы можем включить ее в список, указав название в двойных кавычках:

```basic
#include "MyLibrary.bas"
```

### Цикл WHILE..WEND

Этот тип цикла заставляет его содержимое повторяться до тех пор, пока выполняется условие. Например:

```basic
10 LET A=0
20 PRINT AT 0,0;A
30 LET A=A+1
40 IF INKEY$="" THEN GOTO 20
```

Превращается в:

```basic
DIM A AS UINTEGER
A=0
WHILE INKEY$=""
	PRINT AT 0,0;A
	A=A+1
WEND
```

На первый взгляд видно, что мы не уменьшаем количество строк, мы пишем столько же или даже больше, но зато мы улучшаем читаемость. Код выглядит чище, нам не нужно искать строку `20 GOTO`, и мы также можем добавлять любое число строк кода в тело цикла.

```basic
WHILE 1
     PRINT "Infinite Loop ";
WEND
```

Это приводит к тому, что цикл повторяется бесконечно. Мы также можем принудительно завершить цикл, например, с помощью `BREAK WHILE`:

```basic
WHILE 1
    PRINT "Infinite Loop ";
    IF INKEY$<>"" THEN BREAK WHILE
WEND
```

Хотя этот пример не очень полезен, он помогает нам понять, как выйти из этого цикла.

### Цикл DO..LOOP

Этот тип петли является вариантом предыдущего. Подобно WHILE...WEND, содержимое выполняется до тех пор, пока выполняется условие. Разница в том, что условие может быть помещено в начало цикла, в конец или вообще отсутствовать.

```basic
DO
	PRINT "Infinite Loop ";
LOOP
```

Ещё пример:

```basic
DO
	PRINT "Until you press any key... ";
LOOP WHILE INKEY$=""
```

Есть и другие возможности, например, повторять до тех пор, пока не будет выполнено условие, но мы оставим это на следующий раз...

Нам еще многое предстоит сделать, но это лишь небольшое введение в Boriel ZX Basic.

## Благодарности и атрибуции

Некоторые примеры кода взяты из примеров, поставляемых с NextBuild Дэвида Сапьера (David Saphier AKA em00K).

Спасибо Хосе Родригесу AKA Boriel за помощь и работу над компилятором Boriel ZX Basic.

Помните, что для вопросов вы можете найти меня в twitter "@Duefectu" или Facebook, или на канале "Boriel ZX Basic" в Telegram.

## Перевод

Перевод на русский выполнил Хайдуков Алексей aka Epsilon

Присоединяйтесь к проекту <a href="https://zxdocs.online">**zxdocs.online**</a>!
